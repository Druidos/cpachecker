import argparse
import json
import sys

def load_preplan(path):
    sys.stderr.write("Loading preplan from {}\n".format(path))

    with open(path) as f:
        return json.load(f)

def from_json_function_graph(json_function_graph):
    sys.stderr.write("Converting function graph from JSON-friendly format\n")
    function_graph = {}

    for name, files in json_function_graph.items():
        for file, json_called_functions in files.items():
            called_functions = set()
            function_graph[(name, file)] = called_functions

            for called_name, called_files in json_called_functions.items():
                for called_file in called_files:
                    called_functions.add((called_name, called_file))

    return function_graph

def bfs(graph, root, max_levels, levels):
    nodes = [root]
    levels[root] = 0

    for level in range(max_levels):
        next_nodes = []

        for node in nodes:
            for next_node in graph[node]:
                if next_node not in levels:
                    levels[next_node] = level + 1
                    next_nodes.append(next_node)

        if len(next_nodes) == 0:
            break

        nodes = next_nodes

def collect_functions(function_graph, function, up, down):
    reversed_function_graph = {func: set() for func in function_graph}

    for func, successors in function_graph.items():
        for successor in successors:
            reversed_function_graph[successor].add(func)

    levels_down = {}
    levels_up = {}

    bfs(function_graph, function, down, levels_down)
    bfs(reversed_function_graph, function, up, levels_up)

    functions = {}

    for func, level in levels_down.items():
        functions[func] = {
            "down": level
        }

    for func, level in levels_up.items():
        functions.setdefault(func, {})["up"] = level

    return functions

down_colors = {
    1: "lawngreen",
    2: "green1",
    3: "green4"
}

up_colors = {
    1: "orangered",
    2: "red",
    3: "red4"
}

def get_color(levels):
    if "down" not in levels:
        return up_colors.get(levels["up"], "black")

    if levels["down"] == 0:
        return "yellow"

    if "up" in levels:
        return "grey"

    return down_colors.get(levels["down"], "black")

def get_label(function):
    return "{} ({})".format(*function)

def graph_to_dot(function_graph, functions, root_function):
    lines = ['digraph "{}" {{\n'.format(get_label(root_function))]

    ids = {}
    next_id = 1

    for function, levels in sorted(functions.items()):
        ids[function] = next_id
        lines.append('{} [color = {} label = "{}"]\n'.format(next_id, get_color(levels), get_label(function)))
        next_id += 1

    for function in sorted(functions):
        for next_function in function_graph[function]:
            if next_function in functions:
                lines.append("{} -> {} [color = black style = solid]\n".format(ids[function], ids[next_function]))

    lines.append("}\n")
    return "".join(lines)

def main():
    parser = argparse.ArgumentParser(
        description="Function dependency visualizer")

    parser.add_argument(
        "preplan",
        help="Path to a JSON file containing preplan, as generated by preplan.py.")

    parser.add_argument(
        "function",
        help="Name of the function to look at.")

    parser.add_argument(
        "source_file",
        help="Name of the source file containing the function.",
        nargs="?",
        default=None)

    parser.add_argument(
        "-o", "--output",
        help="Output file, pass '-' or omit to write to stdout.",
        default="-")

    parser.add_argument(
        "-u", "--up",
        help="View given number of call levels above the function.",
        type=int,
        default=1)

    parser.add_argument(
        "-d", "--down",
        help="View given number of call levels below the function.",
        type=int,
        default=1)

    args = parser.parse_args()
    preplan = load_preplan(args.preplan)
    json_function_graph = preplan["function graph"]
    function_graph = from_json_function_graph(json_function_graph)

    name = args.function

    if name not in json_function_graph:
        sys.stderr.write("Unknown function {}\n".format(name))
        return

    files = json_function_graph[name]
    source_file = args.source_file

    if source_file is None:
        if len(files) > 1:
            sys.stderr.write("Function {} has several source files:\n".format(name))
            sys.stderr.write("  {}\n".format(", ".join(files)))
            sys.stderr.write("Choose one with source_file argument\n")
            return

        source_file = next(iter(files))
    elif source_file not in files:
        sys.stderr.write("Unknown source file {} for function {}, candidates:\n".format(source_file, name))
        sys.stderr.write("  {}\n".format(", ".join(files)))
        return

    function = (name, source_file)
    functions = collect_functions(function_graph, function, args.up, args.down)
    dot = graph_to_dot(function_graph, functions, function)

    if args.output == "-":
        output_file = sys.stdout
    else:
        output_file = open(args.output, "w")

    with output_file:
        output_file.write(dot)

if __name__ == "__main__":
    main()
